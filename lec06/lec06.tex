\documentclass{beamer}
\usepackage{inconsolata}
\usepackage{caption}
\usepackage{color}
\usepackage{listings}
\usepackage{subfig}
\usepackage{cooltooltips}
\usepackage{hyperref}
\usepackage{perpage}
\usepackage[normalem]{ulem}
\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\input{../langListingMonokai}

\newenvironment{enum}{
\begin{enumerate}
  \setlength{\itemsep}{1pt}
  \setlength{\parskip}{0pt}
  \setlength{\parsep}{0pt}
}{\end{enumerate}}

\hypersetup{
  colorlinks=true,
  urlcolor=pink,
}

\MakePerPage{footnote}

\title{Python 101}
\subtitle{Lec06 \\ Classes}
\author{thoum}

\begin{document}
\frame{\titlepage}

\begin{frame}
\frametitle{Programming up till now}
Procedure-Oriented Programming\\
We pass values to functions, get values, pass them to another function....
  \begin{center}
  \includegraphics[width=80mm]{./code.png}
  \end{center}
\end{frame}

\begin{frame}
\frametitle{Procedure Oriented Programming}
  When programs get large, Procedure-Oriented might be \textit{too}
  complicated.\\
\end{frame}

\begin{frame}
\frametitle{Object Oriented Programming}
  Combine data and functionality in to an \textit{object}.
  View programs as object communicating with each other.
\end{frame}

\begin{frame}{Objects}
  Integers are objects (of the int class).

  Strings are objects (of the str class).

  $[1,2,3].sort()$ are their class methods, and $len([1,2,3])$ returns their
  internal data: length
\end{frame}

\begin{frame}
\frametitle{Creating Classes of our own}
  We don't usually use classes so much unless we start writing bigger programs.

  The usual Class tutorials force us to create boring examples, like a barking
  dog and a meowing cat.

  We are going to build a basis for a simple RPG game.
\end{frame}

\begin{frame}{The Basis}
  There are two characters in this game(for now).

  The boss, and you.

  They are both \textit{beings}(there are other beings like the halflings,
  dragons, darkelves...).
\end{frame}

\begin{frame}{Beings}
  This becomes the basis(or the \textit{superclass, parentclass}) of all living things that freely
  roam the grounds of the middle earth.  Every \textit{being} can be
  characterized by a name, HP, MP, and their race.
\end{frame}

\begin{frame}{Beings code}
  \begin{lstinputlisting}[firstline=1, lastline=23]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Explanation}
  Names of classes begin with capital letters. (Just a convention, but follow
  it.)
  \begin{lstinputlisting}[firstline=1, lastline=1]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Explanation}
  We annotate classes and functions with triple quotes.
  \begin{lstinputlisting}[firstline=1, lastline=2]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Explanation}
  Class Variables are shared by all instances of the class.
  We will see in detail later.
  \begin{lstinputlisting}[firstline=1, lastline=5]
    {./being.py}
  \end{lstinputlisting}
\end{frame}


\begin{frame}{Explanation}
  Methods whose names are surrounded by 2 underscores
  (\textit{\_\_XXX\_\_}) are
  internal methods.
  They are not meant to be called by the user; they are
  automatically called based on varying situations. We will look into this
  later on.
  \begin{lstinputlisting}[firstline=1, lastline=7]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Explanation}
  \_\_init\_\_ is automatically called upon the creation of an object of the
  class.
  \begin{lstinputlisting}[firstline=7, lastline=14]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Explanation}
  Class methods are same as the functions we have learned, but for one
  \textbf{difference}. They need an extra argument at the beginning of the
  parameter list.\\\textit{But} we \textbf{do not} pass a value for this parameter when we
  \textbf{use} it. The parameter is used to indicate \textit{itself}, hence the
  \textit{\textbf{self}}.(Just a convention, but follow it.)
  \begin{lstinputlisting}[firstline=5, lastline=8]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Explanation}
  The fields(object variables) are created by \_\_init\_\_.\\
  In English, its like saying my$self$'s $name$ is $name$(given by
  \_\_init\_\_).
  \begin{lstinputlisting}[firstline=7, lastline=12]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Explanation}
  To show how we use class/object variables, see the $die(self)$
  method.\footnote{note the $self$!}
  This is used when a battle arises (remember, we were pretending to make an RPG game).
  \begin{lstinputlisting}[firstline=17, lastline=19]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Explanation}
  Just like how we use $self$ to access object variables, we can access Class
  Variables by their class name (Here, $Being$).\\
  Note that when an object changes its $class$ variable, other objects also see
  the change.\\($Class$ variables are not unique to the object).
  \begin{lstinputlisting}[firstline=20, lastline=22]
    {./being.py}
  \end{lstinputlisting}
\end{frame}


\begin{frame}{Using Classes}
  We usually put Class definitions in different files, but for the sake of
  simplicity, lets do it in the same file.\\
  We create an object of a class like the following.
  \begin{lstinputlisting}[firstline=25, lastline=27]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Using Classes}
  Two things to note
  \begin{enumerate}
    \item We didn't call $\_\_init\_\_$.
    \item We didn't add $self$.
  \end{enumerate}
  \begin{lstinputlisting}[firstline=25, lastline=25]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Using Classes}
  We can explicitly use the names of the parameters, for better understanding of the
  code.\footnote{We can actually do this with all functions.}
  \begin{lstinputlisting}[firstline=26, lastline=27]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{The Dragon Slayer}
  We call an object's method like the following. Familiar?
  \begin{lstinputlisting}[firstline=29, lastline=29]
    {./being.py}
  \end{lstinputlisting}
\end{frame}

\begin{frame}{Practice}
  Type and Try
\end{frame}

\begin{frame}{Overriding Internal Functions}
  print((1,2,3)): (1, 2, 3)\\
  print([1,2,3]): [1, 2, 3]\\
  print(3): 3\\
  print(boss): ?\\
  print(you): ?
\end{frame}

\begin{frame}{Overriding Internal Functions}
  To control how $print$ prints a class, we can fill in\\
  $\_\_repr\_\_$\\
  The return value has to be of type $string$, and the return value is what is printed.
\end{frame}

\begin{frame}{Practice}
  In our $Being$ Class, define the $\_\_repr\_\_$, so that printing an object
  of $Being$ Class prints its name, and race.
  ($i.e.$ "This being is a Dragon, of name Smaug")
\end{frame}

\begin{frame}{Combat}
  Now we implement combat for Beings.
  The combat method gets another $Being$, decrease its hp by $3$, and if its hp
  is less or equal than zero, make it die.
\end{frame}

\end{document}
